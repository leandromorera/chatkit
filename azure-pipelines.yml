# Azure DevOps Pipeline para construir y desplegar MCP Weather Service
trigger:
  - main
  - release/*

pool:
  vmImage: ubuntu-latest

variables:
  # Variables generales
  - name: MCP_NAME
    value: 'mcp-weather'
  - name: IMAGE_NAME
    value: '$(MCP_NAME)'
  - name: DOCKERFILE_PATH
    value: '$(System.DefaultWorkingDirectory)/Dockerfile'
  - name: BUILD_CONTEXT
    value: '$(System.DefaultWorkingDirectory)'
  - name: DEPLOYMENT_PATH
    value: '$(System.DefaultWorkingDirectory)/deployment'
  - name: TAG
    value: '$(Build.BuildId)'
  
  # Variables de Azure
  - name: ACR_NAME
    value: 'acr-agentes'
  - name: RESOURCE_GROUP
    value: 'ternium'
  - name: CLUSTER_NAME
    value: 'sharksia-aks'
  - name: AZURE_SUBSCRIPTION
    value: 'agentes-subscription'
  - name: NAMESPACE
    value: 'agentes-inteligentes-laboratorio'
  
  # Control de stages
  - name: BUILD_ENABLED
    value: true
  - name: DEPLOY_ENABLED
    value: true

stages:
  # Stage 1: Construcción de la imagen
  - stage: Build
    displayName: "Build Docker Image"
    condition: eq(variables['BUILD_ENABLED'], 'true')
    jobs:
    - job: BuildImage
      displayName: 'Build and Push Docker Image'
      pool:
        vmImage: ubuntu-latest
      variables:
        - group: 'MCPWeatherSecrets'  # Grupo de variables para este servicio
        - group: 'GeneralVariables'   # Variables compartidas
      steps:
      # Paso 1: Login al Azure Container Registry
      - task: Docker@2
        displayName: 'Login to ACR'
        inputs:
          command: login
          containerRegistry: '$(ACR_NAME)'
      
      # Paso 2: Construir y subir la imagen
      - task: Docker@2
        displayName: 'Build and Push Image'
        inputs:
          command: buildAndPush
          containerRegistry: '$(ACR_NAME)'
          repository: '$(IMAGE_NAME)'
          Dockerfile: '$(DOCKERFILE_PATH)'
          buildContext: '$(BUILD_CONTEXT)'
          tags: |
            latest
            $(TAG)
          arguments: '--build-arg ENVIRONMENT=production'
      
      # Paso 3: Guardar información del build
      - task: Bash@3
        displayName: 'Save Build Information'
        inputs:
          targetType: 'inline'
          script: |
            echo "##vso[task.setvariable variable=FULL_IMAGE_NAME;]$(ACR_NAME).azurecr.io/$(IMAGE_NAME):$(TAG)"
            echo "Image built and pushed: $(ACR_NAME).azurecr.io/$(IMAGE_NAME):$(TAG)"
            echo "Build ID: $(Build.BuildId)"
            echo "Build Number: $(Build.BuildNumber)"

  # Stage 2: Despliegue en AKS
  - stage: Deploy
    displayName: "Deploy to AKS"
    dependsOn: Build
    condition: and(succeeded(), eq(variables['DEPLOY_ENABLED'], 'true'))
    jobs:
    - job: DeployToAKS
      displayName: 'Deploy to Kubernetes'
      pool:
        vmImage: ubuntu-latest
      variables:
        - group: 'MCPWeatherSecrets'
        - group: 'GeneralVariables'
      steps:
      # Paso 1: Configurar kubectl
      - task: AzureCLI@2
        displayName: 'Configure kubectl'
        inputs:
          azureSubscription: '$(AZURE_SUBSCRIPTION)'
          scriptType: 'bash'
          scriptLocation: 'inlineScript'
          inlineScript: |
            az aks get-credentials \
              --resource-group $(RESOURCE_GROUP) \
              --name $(CLUSTER_NAME) \
              --overwrite-existing
            
            # Verificar conexión
            kubectl config current-context
            kubectl cluster-info
      
      # Paso 2: Crear namespace si no existe
      - task: Kubernetes@1
        displayName: 'Create Namespace if not exists'
        inputs:
          connectionType: 'Azure Resource Manager'
          azureSubscriptionEndpoint: '$(AZURE_SUBSCRIPTION)'
          azureResourceGroup: '$(RESOURCE_GROUP)'
          kubernetesCluster: '$(CLUSTER_NAME)'
          namespace: '$(NAMESPACE)'
          command: 'apply'
          useConfigurationFile: true
          configuration: |
            apiVersion: v1
            kind: Namespace
            metadata:
              name: $(NAMESPACE)
      
      # Paso 3: Reemplazar variables en manifiestos
      - task: replacetokens@6
        displayName: "Replace tokens in manifests"
        inputs:
          rootDirectory: '$(DEPLOYMENT_PATH)'
          targetFiles: '*.yaml'
          encoding: 'auto'
          tokenPattern: 'default'
          writeBOM: true
          actionOnMissing: 'warn'
          keepToken: false
          actionOnNoFiles: 'warn'
          enableTransforms: false
          enableRecursion: false
          useLegacyPattern: false
          enableTelemetry: true
      
      # Paso 4: Aplicar ConfigMap
      - task: Kubernetes@1
        displayName: 'Apply ConfigMap'
        inputs:
          connectionType: 'Azure Resource Manager'
          azureSubscriptionEndpoint: '$(AZURE_SUBSCRIPTION)'
          azureResourceGroup: '$(RESOURCE_GROUP)'
          kubernetesCluster: '$(CLUSTER_NAME)'
          namespace: '$(NAMESPACE)'
          command: 'apply'
          arguments: '--validate=true'
          useConfigurationFile: true
          configuration: '$(DEPLOYMENT_PATH)/01-configmap.yaml'
      
      # Paso 5: Aplicar Deployment
      - task: Kubernetes@1
        displayName: 'Apply Deployment'
        inputs:
          connectionType: 'Azure Resource Manager'
          azureSubscriptionEndpoint: '$(AZURE_SUBSCRIPTION)'
          azureResourceGroup: '$(RESOURCE_GROUP)'
          kubernetesCluster: '$(CLUSTER_NAME)'
          namespace: '$(NAMESPACE)'
          command: 'apply'
          arguments: '--validate=true'
          useConfigurationFile: true
          configuration: '$(DEPLOYMENT_PATH)/02-deployment.yaml'
      
      # Paso 6: Aplicar Service
      - task: Kubernetes@1
        displayName: 'Apply Service'
        inputs:
          connectionType: 'Azure Resource Manager'
          azureSubscriptionEndpoint: '$(AZURE_SUBSCRIPTION)'
          azureResourceGroup: '$(RESOURCE_GROUP)'
          kubernetesCluster: '$(CLUSTER_NAME)'
          namespace: '$(NAMESPACE)'
          command: 'apply'
          arguments: '--validate=true'
          useConfigurationFile: true
          configuration: '$(DEPLOYMENT_PATH)/03-service.yaml'
      
      # Paso 7: Verificar despliegue
      - task: Bash@3
        displayName: 'Verify Deployment'
        inputs:
          targetType: 'inline'
          script: |
            echo "Verificando estado del despliegue..."
            echo "=== Pods ==="
            kubectl get pods -n $(NAMESPACE) -l app=$(MCP_NAME) --watch
            
            echo "=== Services ==="
            kubectl get svc -n $(NAMESPACE) $(MCP_NAME)-service
            
            echo "=== Deployment ==="
            kubectl get deployment -n $(NAMESPACE) $(MCP_NAME)
            
            # Esperar a que los pods estén listos
            kubectl wait --for=condition=available --timeout=300s \
              deployment/$(MCP_NAME) -n $(NAMESPACE)
            
            echo "✅ Despliegue completado exitosamente!"

  # Stage 3: Smoke Tests (Opcional)
  - stage: SmokeTest
    displayName: "Smoke Tests"
    dependsOn: Deploy
    condition: succeeded()
    jobs:
    - job: RunSmokeTests
      displayName: 'Run Smoke Tests'
      pool:
        vmImage: ubuntu-latest
      steps:
      - task: AzureCLI@2
        displayName: 'Test Service Connectivity'
        inputs:
          azureSubscription: '$(AZURE_SUBSCRIPTION)'
          scriptType: 'bash'
          scriptLocation: 'inlineScript'
          inlineScript: |
            # Obtener IP externa del servicio
            SERVICE_IP=$(kubectl get svc -n $(NAMESPACE) $(MCP_NAME)-service \
              -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
            
            echo "Service IP: $SERVICE_IP"
            
            # Test de conectividad
            if [ -n "$SERVICE_IP" ]; then
              echo "Testing service at http://$SERVICE_IP/health"
              curl -f http://$SERVICE_IP/health || exit 1
              echo "✅ Service is responding"
            else
              echo "⚠️ Service IP not available yet"
            fi